# Тестовое задание стажировка Авито (зима 2025)

## Общая информация :

- Музыкальный плеер. 
- Первый экран - deezer, по умолчанию идёт загрузка треков из chart + поиск по deezer.
- Второй экран - список треков с устройства, получен через Cursor + поиск по списку.

В списках отражены название трека, имя автора и картинка альбома.

Между двумя экранами с треками переключение через BottomNavigation. 
По нажатию на элемент списка открывается экран плеера, а также запускается сервис.

- Плеер. Отражены картинка альбома, название трека, название альбома, имя автора. Навигация между треками в списке, пауза/воспроизведение. 

Проигрывание музыки осуществляется через сервис с показом уведомления. 
В уведомлении отражено название трека, а также присутствуют 
кнопки пауза/воспроизведение, следующий трек, предыдущий трек.


## Использованные технологии :

- **Язык**: kotlin
- **Работа с сетью**: Retrofit2, OkHttp
- **Многопоточность**: Kotlin Coroutines/Flow
- **View**: Jetpack Compose, Coil
- **Сериализаторы**: Gson
- **Навигация**: Jetpack Navigation
- **Архитектура**: MVVM
- **Плеер**: Media 3 ExoPlayer

### **Схема приложения**

- В приложении 4 модуля - app, core, local, remote.
- Модуль core содержит константы, модель трека, переиспользуемый элемент списка треков, а также SharedDataManager - синглтон-объект для связи с сервисом через SharedFlow.
- Модули local и remote содержат логику получения списка треков, соответственно с устройства и из указанного интернет-ресурса. Также модули содержат composable-функции для
отображения экранов со списками треков (я не стал делать общий экран треков из-за зависимости экранов от ViewModel, которая у каждого источника данных своя)
- Модуль app содержит навигацию между экранами, логику запрашивания разрешений, а также предварительно запускает boundService


## Проблемы и ход решения

- Реализованный механизм отправки уведомлений неоптимален, я не стал использовать MediaSessionService (и связанные с ним классы) из-за того, что не имел достаточного
количества времени чтобы разобраться в технологии.
- Частично из-за нехватки времени и, в большей степени, опыта использования я реализовал Hilt вместо Dagger.
- Также в связи с полным отсутствием опыта работы с ветками (всегда всё делал в одиночку и распределять фичи по веткам не было необходимости) всё выложено в master

## Видео работы приложения
https://github.com/user-attachments/assets/1a8d4edf-166d-455a-a2e1-c7146964ad08

# **ВАЖНО** Найденные баги и недоработки

- В процессе тестирования приложения уже после сдачи проекта на проверку мной были обнаружены следующие баги и недоработки. 
Разумеется я не буду править код приложения т.к. дедлайн прошел, однако считаю уместным отразить информацию по фиксу в readme.

## Проблема : плохая разметка экранов при смене ориентации устройства.
Решение : 
- "плохое" решение - залочить ориентацию в приложении.
- "хорошее" решение - отслеживать в переменной (или в функции с возвращаемым boolean) состояние ориентации устройства 
и передавать его в composable-функции экранов. 

Для экранов со списками треков - использовать (при ориентации landscape) вместо LazyColumn -> LazyVerticalGrid, в которой 
можно указать как количество столбцов, так и (для больших экранов) максимальную ширину столбца. Также при ориентации landscape
можно выбирать другое значение параметра height для BottomNavigation и TextField с поиском.

Для экрана плеера - в зависимости от ориентации экрана менять parent-элемент, предположим если в portrait используется Column, то
в landscape - Row (с дочерними Column) и тому подобное.

## Проблема : при смахивании уведомления воспроизведение музыки не останавливается.

Решение : использовать при создании уведомления параметр .setDeleteIntent.

## Проблема : в гитхаб-репозитории присутствует ненужная папка (бывший модуль приложения) player.

Решение (или, в данном случае, объяснение) : при написании проекта на первых этапах ExoPlayer "жил" в собственной viewModel,
для чего был создан отдельный модуль. В дальнейшем (когда мною были настроены способы получения списков треков из апи и из устройства)
плеер "переехал" в собственный Service, и надобность во viewModel отпала. Я удалил из проекта модуль player, но не обратил внимание 
на то, что фактически файлы и папки с диска удалены не были, и при push проекта на гитхаб - улетели вместе с реально используемыми
файлами. Удалять папку напрямую из репозитория нельзя т.к. будет ругаться merger при попытке запуска приложения.

## Проблема : если сменить ориентацию во время того, как активен экран плеера - приложение выбрасывает exception.

Решение состоит из двух частей. 
Первая часть: Исключение, выбрасываемое приложением - NullPointerException, при попытке инициализировать плеер на контексте 
сервиса (который, в свою очередь, создан через Intent с контекстом MainActivity) в случае пересоздания активити контекст оказывается
null. Для предотвращения вылета приложения необходимо поменять контекст активити на контекст application, а также сделать
объект exoPlayer в сервисе нуллабельным (и, разумеется, добавить в экран плеера проверки на null у кнопок общения с плеером), что
дает сервису время для инициализации exoPlayer в onCreate.

Решение первой проблемы создает вторую - при перевороте экрана выбрасывается IndexOutOfBoundsException. Это происходит из-за того, 
что отныне защищенный от пересоздания активити экран плеера принимает в качестве аргументов список треков и индекс, а поскольку 
подписка на SharedFlow со списком происходит в onCreate сервиса - при вызове composable-функции плеера список оказывается пустым.
Решение второй проблемы: добавить проверку list.isNotEmpty при вызове composable-функции плеера. Так как список загружать из интернета
не требуется (он хранится в SharedDataManager), то при вызове onCreate сервиса список будет подтянут и 
зависания экрана не произойдет.


## Проблема : если отфильтровать список треков, включить плеер, а потом вернуться обратно на экран списка - отображаться будет не отфильтрованный список, а изначальный (то есть /chart из апи и полный список треков с устройства).

Решение : сохранять состояние списка ИЛИ запрос в строке поиска (предположим во viewModel). В случае сохранения запроса - 
при возврате на экран изначальный список будет заново отфильтрован по имеющемуся запросу.

## Проблема : при загрузке треков с устройства учитываются не только музыкальные треки, но и голосовые сообщения из мессенджеров.

Решение : использовать в настройках объекта Cursor только характерные для музыки MIME-типы.
